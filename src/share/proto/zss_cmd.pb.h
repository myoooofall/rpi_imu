// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zss_cmd.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_zss_5fcmd_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_zss_5fcmd_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "zss_cmd_type.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_zss_5fcmd_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_zss_5fcmd_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_zss_5fcmd_2eproto;
namespace ZSS {
namespace New {
class Multicast_Status;
class Multicast_StatusDefaultTypeInternal;
extern Multicast_StatusDefaultTypeInternal _Multicast_Status_default_instance_;
class Robot_Command;
class Robot_CommandDefaultTypeInternal;
extern Robot_CommandDefaultTypeInternal _Robot_Command_default_instance_;
class Robot_Status;
class Robot_StatusDefaultTypeInternal;
extern Robot_StatusDefaultTypeInternal _Robot_Status_default_instance_;
class Robots_Command;
class Robots_CommandDefaultTypeInternal;
extern Robots_CommandDefaultTypeInternal _Robots_Command_default_instance_;
class Robots_Status;
class Robots_StatusDefaultTypeInternal;
extern Robots_StatusDefaultTypeInternal _Robots_Status_default_instance_;
}  // namespace New
}  // namespace ZSS
PROTOBUF_NAMESPACE_OPEN
template<> ::ZSS::New::Multicast_Status* Arena::CreateMaybeMessage<::ZSS::New::Multicast_Status>(Arena*);
template<> ::ZSS::New::Robot_Command* Arena::CreateMaybeMessage<::ZSS::New::Robot_Command>(Arena*);
template<> ::ZSS::New::Robot_Status* Arena::CreateMaybeMessage<::ZSS::New::Robot_Status>(Arena*);
template<> ::ZSS::New::Robots_Command* Arena::CreateMaybeMessage<::ZSS::New::Robots_Command>(Arena*);
template<> ::ZSS::New::Robots_Status* Arena::CreateMaybeMessage<::ZSS::New::Robots_Status>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ZSS {
namespace New {

enum Robot_Command_KickMode : int {
  Robot_Command_KickMode_NONE = 0,
  Robot_Command_KickMode_KICK = 1,
  Robot_Command_KickMode_CHIP = 2,
  Robot_Command_KickMode_Robot_Command_KickMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Robot_Command_KickMode_Robot_Command_KickMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Robot_Command_KickMode_IsValid(int value);
constexpr Robot_Command_KickMode Robot_Command_KickMode_KickMode_MIN = Robot_Command_KickMode_NONE;
constexpr Robot_Command_KickMode Robot_Command_KickMode_KickMode_MAX = Robot_Command_KickMode_CHIP;
constexpr int Robot_Command_KickMode_KickMode_ARRAYSIZE = Robot_Command_KickMode_KickMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Robot_Command_KickMode_descriptor();
template<typename T>
inline const std::string& Robot_Command_KickMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Robot_Command_KickMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Robot_Command_KickMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Robot_Command_KickMode_descriptor(), enum_t_value);
}
inline bool Robot_Command_KickMode_Parse(
    const std::string& name, Robot_Command_KickMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Robot_Command_KickMode>(
    Robot_Command_KickMode_descriptor(), name, value);
}
enum Robot_Command_CmdType : int {
  Robot_Command_CmdType_STOP = 0,
  Robot_Command_CmdType_CMD_WHEEL = 1,
  Robot_Command_CmdType_CMD_VEL = 2,
  Robot_Command_CmdType_CMD_POSE = 3,
  Robot_Command_CmdType_CMD_CHASE = 4,
  Robot_Command_CmdType_Robot_Command_CmdType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Robot_Command_CmdType_Robot_Command_CmdType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Robot_Command_CmdType_IsValid(int value);
constexpr Robot_Command_CmdType Robot_Command_CmdType_CmdType_MIN = Robot_Command_CmdType_STOP;
constexpr Robot_Command_CmdType Robot_Command_CmdType_CmdType_MAX = Robot_Command_CmdType_CMD_CHASE;
constexpr int Robot_Command_CmdType_CmdType_ARRAYSIZE = Robot_Command_CmdType_CmdType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Robot_Command_CmdType_descriptor();
template<typename T>
inline const std::string& Robot_Command_CmdType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Robot_Command_CmdType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Robot_Command_CmdType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Robot_Command_CmdType_descriptor(), enum_t_value);
}
inline bool Robot_Command_CmdType_Parse(
    const std::string& name, Robot_Command_CmdType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Robot_Command_CmdType>(
    Robot_Command_CmdType_descriptor(), name, value);
}
enum Robot_Command_CommType : int {
  Robot_Command_CommType_DEFAULT = 0,
  Robot_Command_CommType_SERIAL = 1,
  Robot_Command_CommType_UDP_24L01 = 2,
  Robot_Command_CommType_UDP_WIFI = 3,
  Robot_Command_CommType_Robot_Command_CommType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Robot_Command_CommType_Robot_Command_CommType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Robot_Command_CommType_IsValid(int value);
constexpr Robot_Command_CommType Robot_Command_CommType_CommType_MIN = Robot_Command_CommType_DEFAULT;
constexpr Robot_Command_CommType Robot_Command_CommType_CommType_MAX = Robot_Command_CommType_UDP_WIFI;
constexpr int Robot_Command_CommType_CommType_ARRAYSIZE = Robot_Command_CommType_CommType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Robot_Command_CommType_descriptor();
template<typename T>
inline const std::string& Robot_Command_CommType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Robot_Command_CommType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Robot_Command_CommType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Robot_Command_CommType_descriptor(), enum_t_value);
}
inline bool Robot_Command_CommType_Parse(
    const std::string& name, Robot_Command_CommType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Robot_Command_CommType>(
    Robot_Command_CommType_descriptor(), name, value);
}
enum Team : int {
  UNKNOWN = 0,
  BLUE = 1,
  YELLOW = 2,
  Team_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Team_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Team_IsValid(int value);
constexpr Team Team_MIN = UNKNOWN;
constexpr Team Team_MAX = YELLOW;
constexpr int Team_ARRAYSIZE = Team_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Team_descriptor();
template<typename T>
inline const std::string& Team_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Team>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Team_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Team_descriptor(), enum_t_value);
}
inline bool Team_Parse(
    const std::string& name, Team* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Team>(
    Team_descriptor(), name, value);
}
// ===================================================================

class Robots_Status PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ZSS.New.Robots_Status) */ {
 public:
  inline Robots_Status() : Robots_Status(nullptr) {};
  virtual ~Robots_Status();

  Robots_Status(const Robots_Status& from);
  Robots_Status(Robots_Status&& from) noexcept
    : Robots_Status() {
    *this = ::std::move(from);
  }

  inline Robots_Status& operator=(const Robots_Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robots_Status& operator=(Robots_Status&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Robots_Status& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Robots_Status* internal_default_instance() {
    return reinterpret_cast<const Robots_Status*>(
               &_Robots_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Robots_Status& a, Robots_Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Robots_Status* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robots_Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Robots_Status* New() const final {
    return CreateMaybeMessage<Robots_Status>(nullptr);
  }

  Robots_Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Robots_Status>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Robots_Status& from);
  void MergeFrom(const Robots_Status& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robots_Status* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ZSS.New.Robots_Status";
  }
  protected:
  explicit Robots_Status(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_zss_5fcmd_2eproto);
    return ::descriptor_table_zss_5fcmd_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotsStatusFieldNumber = 1,
  };
  // repeated .ZSS.New.Robot_Status robots_status = 1;
  int robots_status_size() const;
  private:
  int _internal_robots_status_size() const;
  public:
  void clear_robots_status();
  ::ZSS::New::Robot_Status* mutable_robots_status(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ZSS::New::Robot_Status >*
      mutable_robots_status();
  private:
  const ::ZSS::New::Robot_Status& _internal_robots_status(int index) const;
  ::ZSS::New::Robot_Status* _internal_add_robots_status();
  public:
  const ::ZSS::New::Robot_Status& robots_status(int index) const;
  ::ZSS::New::Robot_Status* add_robots_status();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ZSS::New::Robot_Status >&
      robots_status() const;

  // @@protoc_insertion_point(class_scope:ZSS.New.Robots_Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ZSS::New::Robot_Status > robots_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zss_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class Multicast_Status PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ZSS.New.Multicast_Status) */ {
 public:
  inline Multicast_Status() : Multicast_Status(nullptr) {};
  virtual ~Multicast_Status();

  Multicast_Status(const Multicast_Status& from);
  Multicast_Status(Multicast_Status&& from) noexcept
    : Multicast_Status() {
    *this = ::std::move(from);
  }

  inline Multicast_Status& operator=(const Multicast_Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Multicast_Status& operator=(Multicast_Status&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Multicast_Status& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Multicast_Status* internal_default_instance() {
    return reinterpret_cast<const Multicast_Status*>(
               &_Multicast_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Multicast_Status& a, Multicast_Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Multicast_Status* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Multicast_Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Multicast_Status* New() const final {
    return CreateMaybeMessage<Multicast_Status>(nullptr);
  }

  Multicast_Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Multicast_Status>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Multicast_Status& from);
  void MergeFrom(const Multicast_Status& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Multicast_Status* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ZSS.New.Multicast_Status";
  }
  protected:
  explicit Multicast_Status(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_zss_5fcmd_2eproto);
    return ::descriptor_table_zss_5fcmd_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kUuidFieldNumber = 2,
    kTeamFieldNumber = 3,
    kRobotIdFieldNumber = 4,
    kBatteryFieldNumber = 5,
    kCapacitanceFieldNumber = 6,
  };
  // string ip = 1;
  void clear_ip();
  const std::string& ip() const;
  void set_ip(const std::string& value);
  void set_ip(std::string&& value);
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  std::string* mutable_ip();
  std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ip();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ip(
      std::string* ip);
  private:
  const std::string& _internal_ip() const;
  void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // string uuid = 2;
  void clear_uuid();
  const std::string& uuid() const;
  void set_uuid(const std::string& value);
  void set_uuid(std::string&& value);
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  std::string* mutable_uuid();
  std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_uuid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_uuid(
      std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // .ZSS.New.Team team = 3;
  void clear_team();
  ::ZSS::New::Team team() const;
  void set_team(::ZSS::New::Team value);
  private:
  ::ZSS::New::Team _internal_team() const;
  void _internal_set_team(::ZSS::New::Team value);
  public:

  // int32 robot_id = 4;
  void clear_robot_id();
  ::PROTOBUF_NAMESPACE_ID::int32 robot_id() const;
  void set_robot_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_robot_id() const;
  void _internal_set_robot_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float battery = 5;
  void clear_battery();
  float battery() const;
  void set_battery(float value);
  private:
  float _internal_battery() const;
  void _internal_set_battery(float value);
  public:

  // float capacitance = 6;
  void clear_capacitance();
  float capacitance() const;
  void set_capacitance(float value);
  private:
  float _internal_capacitance() const;
  void _internal_set_capacitance(float value);
  public:

  // @@protoc_insertion_point(class_scope:ZSS.New.Multicast_Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
  int team_;
  ::PROTOBUF_NAMESPACE_ID::int32 robot_id_;
  float battery_;
  float capacitance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zss_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class Robot_Status PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ZSS.New.Robot_Status) */ {
 public:
  inline Robot_Status() : Robot_Status(nullptr) {};
  virtual ~Robot_Status();

  Robot_Status(const Robot_Status& from);
  Robot_Status(Robot_Status&& from) noexcept
    : Robot_Status() {
    *this = ::std::move(from);
  }

  inline Robot_Status& operator=(const Robot_Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_Status& operator=(Robot_Status&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Robot_Status& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Robot_Status* internal_default_instance() {
    return reinterpret_cast<const Robot_Status*>(
               &_Robot_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Robot_Status& a, Robot_Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_Status* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Robot_Status* New() const final {
    return CreateMaybeMessage<Robot_Status>(nullptr);
  }

  Robot_Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Robot_Status>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Robot_Status& from);
  void MergeFrom(const Robot_Status& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot_Status* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ZSS.New.Robot_Status";
  }
  protected:
  explicit Robot_Status(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_zss_5fcmd_2eproto);
    return ::descriptor_table_zss_5fcmd_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWheelEncoderFieldNumber = 9,
    kOdomFieldNumber = 8,
    kRobotIdFieldNumber = 1,
    kInfraredFieldNumber = 2,
    kFlatKickFieldNumber = 3,
    kChipKickFieldNumber = 4,
    kImuThetaFieldNumber = 5,
    kBatteryFieldNumber = 6,
    kCapacitanceFieldNumber = 7,
    kTeamFieldNumber = 10,
  };
  // repeated float wheel_encoder = 9;
  int wheel_encoder_size() const;
  private:
  int _internal_wheel_encoder_size() const;
  public:
  void clear_wheel_encoder();
  private:
  float _internal_wheel_encoder(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_wheel_encoder() const;
  void _internal_add_wheel_encoder(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_wheel_encoder();
  public:
  float wheel_encoder(int index) const;
  void set_wheel_encoder(int index, float value);
  void add_wheel_encoder(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      wheel_encoder() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_wheel_encoder();

  // .ZSS.New.Odom odom = 8;
  bool has_odom() const;
  private:
  bool _internal_has_odom() const;
  public:
  void clear_odom();
  const ::ZSS::New::Odom& odom() const;
  ::ZSS::New::Odom* release_odom();
  ::ZSS::New::Odom* mutable_odom();
  void set_allocated_odom(::ZSS::New::Odom* odom);
  private:
  const ::ZSS::New::Odom& _internal_odom() const;
  ::ZSS::New::Odom* _internal_mutable_odom();
  public:
  void unsafe_arena_set_allocated_odom(
      ::ZSS::New::Odom* odom);
  ::ZSS::New::Odom* unsafe_arena_release_odom();

  // int32 robot_id = 1;
  void clear_robot_id();
  ::PROTOBUF_NAMESPACE_ID::int32 robot_id() const;
  void set_robot_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_robot_id() const;
  void _internal_set_robot_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float infrared = 2;
  void clear_infrared();
  float infrared() const;
  void set_infrared(float value);
  private:
  float _internal_infrared() const;
  void _internal_set_infrared(float value);
  public:

  // float flat_kick = 3;
  void clear_flat_kick();
  float flat_kick() const;
  void set_flat_kick(float value);
  private:
  float _internal_flat_kick() const;
  void _internal_set_flat_kick(float value);
  public:

  // float chip_kick = 4;
  void clear_chip_kick();
  float chip_kick() const;
  void set_chip_kick(float value);
  private:
  float _internal_chip_kick() const;
  void _internal_set_chip_kick(float value);
  public:

  // float imu_theta = 5;
  void clear_imu_theta();
  float imu_theta() const;
  void set_imu_theta(float value);
  private:
  float _internal_imu_theta() const;
  void _internal_set_imu_theta(float value);
  public:

  // float battery = 6;
  void clear_battery();
  float battery() const;
  void set_battery(float value);
  private:
  float _internal_battery() const;
  void _internal_set_battery(float value);
  public:

  // float capacitance = 7;
  void clear_capacitance();
  float capacitance() const;
  void set_capacitance(float value);
  private:
  float _internal_capacitance() const;
  void _internal_set_capacitance(float value);
  public:

  // .ZSS.New.Team team = 10;
  void clear_team();
  ::ZSS::New::Team team() const;
  void set_team(::ZSS::New::Team value);
  private:
  ::ZSS::New::Team _internal_team() const;
  void _internal_set_team(::ZSS::New::Team value);
  public:

  // @@protoc_insertion_point(class_scope:ZSS.New.Robot_Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > wheel_encoder_;
  mutable std::atomic<int> _wheel_encoder_cached_byte_size_;
  ::ZSS::New::Odom* odom_;
  ::PROTOBUF_NAMESPACE_ID::int32 robot_id_;
  float infrared_;
  float flat_kick_;
  float chip_kick_;
  float imu_theta_;
  float battery_;
  float capacitance_;
  int team_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zss_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class Robots_Command PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ZSS.New.Robots_Command) */ {
 public:
  inline Robots_Command() : Robots_Command(nullptr) {};
  virtual ~Robots_Command();

  Robots_Command(const Robots_Command& from);
  Robots_Command(Robots_Command&& from) noexcept
    : Robots_Command() {
    *this = ::std::move(from);
  }

  inline Robots_Command& operator=(const Robots_Command& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robots_Command& operator=(Robots_Command&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Robots_Command& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Robots_Command* internal_default_instance() {
    return reinterpret_cast<const Robots_Command*>(
               &_Robots_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Robots_Command& a, Robots_Command& b) {
    a.Swap(&b);
  }
  inline void Swap(Robots_Command* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robots_Command* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Robots_Command* New() const final {
    return CreateMaybeMessage<Robots_Command>(nullptr);
  }

  Robots_Command* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Robots_Command>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Robots_Command& from);
  void MergeFrom(const Robots_Command& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robots_Command* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ZSS.New.Robots_Command";
  }
  protected:
  explicit Robots_Command(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_zss_5fcmd_2eproto);
    return ::descriptor_table_zss_5fcmd_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 1,
    kDelayFieldNumber = 2,
  };
  // repeated .ZSS.New.Robot_Command command = 1;
  int command_size() const;
  private:
  int _internal_command_size() const;
  public:
  void clear_command();
  ::ZSS::New::Robot_Command* mutable_command(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ZSS::New::Robot_Command >*
      mutable_command();
  private:
  const ::ZSS::New::Robot_Command& _internal_command(int index) const;
  ::ZSS::New::Robot_Command* _internal_add_command();
  public:
  const ::ZSS::New::Robot_Command& command(int index) const;
  ::ZSS::New::Robot_Command* add_command();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ZSS::New::Robot_Command >&
      command() const;

  // int32 delay = 2;
  bool has_delay() const;
  private:
  bool _internal_has_delay() const;
  public:
  void clear_delay();
  ::PROTOBUF_NAMESPACE_ID::int32 delay() const;
  void set_delay(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_delay() const;
  void _internal_set_delay(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ZSS.New.Robots_Command)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ZSS::New::Robot_Command > command_;
  ::PROTOBUF_NAMESPACE_ID::int32 delay_;
  friend struct ::TableStruct_zss_5fcmd_2eproto;
};
// -------------------------------------------------------------------

class Robot_Command PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ZSS.New.Robot_Command) */ {
 public:
  inline Robot_Command() : Robot_Command(nullptr) {};
  virtual ~Robot_Command();

  Robot_Command(const Robot_Command& from);
  Robot_Command(Robot_Command&& from) noexcept
    : Robot_Command() {
    *this = ::std::move(from);
  }

  inline Robot_Command& operator=(const Robot_Command& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot_Command& operator=(Robot_Command&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Robot_Command& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Robot_Command* internal_default_instance() {
    return reinterpret_cast<const Robot_Command*>(
               &_Robot_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Robot_Command& a, Robot_Command& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot_Command* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot_Command* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Robot_Command* New() const final {
    return CreateMaybeMessage<Robot_Command>(nullptr);
  }

  Robot_Command* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Robot_Command>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Robot_Command& from);
  void MergeFrom(const Robot_Command& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot_Command* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ZSS.New.Robot_Command";
  }
  protected:
  explicit Robot_Command(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_zss_5fcmd_2eproto);
    return ::descriptor_table_zss_5fcmd_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Robot_Command_KickMode KickMode;
  static constexpr KickMode NONE =
    Robot_Command_KickMode_NONE;
  static constexpr KickMode KICK =
    Robot_Command_KickMode_KICK;
  static constexpr KickMode CHIP =
    Robot_Command_KickMode_CHIP;
  static inline bool KickMode_IsValid(int value) {
    return Robot_Command_KickMode_IsValid(value);
  }
  static constexpr KickMode KickMode_MIN =
    Robot_Command_KickMode_KickMode_MIN;
  static constexpr KickMode KickMode_MAX =
    Robot_Command_KickMode_KickMode_MAX;
  static constexpr int KickMode_ARRAYSIZE =
    Robot_Command_KickMode_KickMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  KickMode_descriptor() {
    return Robot_Command_KickMode_descriptor();
  }
  template<typename T>
  static inline const std::string& KickMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, KickMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function KickMode_Name.");
    return Robot_Command_KickMode_Name(enum_t_value);
  }
  static inline bool KickMode_Parse(const std::string& name,
      KickMode* value) {
    return Robot_Command_KickMode_Parse(name, value);
  }

  typedef Robot_Command_CmdType CmdType;
  static constexpr CmdType STOP =
    Robot_Command_CmdType_STOP;
  static constexpr CmdType CMD_WHEEL =
    Robot_Command_CmdType_CMD_WHEEL;
  static constexpr CmdType CMD_VEL =
    Robot_Command_CmdType_CMD_VEL;
  static constexpr CmdType CMD_POSE =
    Robot_Command_CmdType_CMD_POSE;
  static constexpr CmdType CMD_CHASE =
    Robot_Command_CmdType_CMD_CHASE;
  static inline bool CmdType_IsValid(int value) {
    return Robot_Command_CmdType_IsValid(value);
  }
  static constexpr CmdType CmdType_MIN =
    Robot_Command_CmdType_CmdType_MIN;
  static constexpr CmdType CmdType_MAX =
    Robot_Command_CmdType_CmdType_MAX;
  static constexpr int CmdType_ARRAYSIZE =
    Robot_Command_CmdType_CmdType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CmdType_descriptor() {
    return Robot_Command_CmdType_descriptor();
  }
  template<typename T>
  static inline const std::string& CmdType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CmdType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CmdType_Name.");
    return Robot_Command_CmdType_Name(enum_t_value);
  }
  static inline bool CmdType_Parse(const std::string& name,
      CmdType* value) {
    return Robot_Command_CmdType_Parse(name, value);
  }

  typedef Robot_Command_CommType CommType;
  static constexpr CommType DEFAULT =
    Robot_Command_CommType_DEFAULT;
  static constexpr CommType SERIAL =
    Robot_Command_CommType_SERIAL;
  static constexpr CommType UDP_24L01 =
    Robot_Command_CommType_UDP_24L01;
  static constexpr CommType UDP_WIFI =
    Robot_Command_CommType_UDP_WIFI;
  static inline bool CommType_IsValid(int value) {
    return Robot_Command_CommType_IsValid(value);
  }
  static constexpr CommType CommType_MIN =
    Robot_Command_CommType_CommType_MIN;
  static constexpr CommType CommType_MAX =
    Robot_Command_CommType_CommType_MAX;
  static constexpr int CommType_ARRAYSIZE =
    Robot_Command_CommType_CommType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CommType_descriptor() {
    return Robot_Command_CommType_descriptor();
  }
  template<typename T>
  static inline const std::string& CommType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CommType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CommType_Name.");
    return Robot_Command_CommType_Name(enum_t_value);
  }
  static inline bool CommType_Parse(const std::string& name,
      CommType* value) {
    return Robot_Command_CommType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCmdVelFieldNumber = 8,
    kCmdPoseFieldNumber = 9,
    kCmdChaseFieldNumber = 10,
    kCmdWheelFieldNumber = 11,
    kRobotIdFieldNumber = 1,
    kKickModeFieldNumber = 2,
    kDesirePowerFieldNumber = 3,
    kKickDischargeTimeFieldNumber = 4,
    kDribbleSpinFieldNumber = 5,
    kNeedReportFieldNumber = 6,
    kCmdTypeFieldNumber = 7,
    kCommTypeFieldNumber = 12,
  };
  // .ZSS.New.CmdVel cmd_vel = 8;
  bool has_cmd_vel() const;
  private:
  bool _internal_has_cmd_vel() const;
  public:
  void clear_cmd_vel();
  const ::ZSS::New::CmdVel& cmd_vel() const;
  ::ZSS::New::CmdVel* release_cmd_vel();
  ::ZSS::New::CmdVel* mutable_cmd_vel();
  void set_allocated_cmd_vel(::ZSS::New::CmdVel* cmd_vel);
  private:
  const ::ZSS::New::CmdVel& _internal_cmd_vel() const;
  ::ZSS::New::CmdVel* _internal_mutable_cmd_vel();
  public:
  void unsafe_arena_set_allocated_cmd_vel(
      ::ZSS::New::CmdVel* cmd_vel);
  ::ZSS::New::CmdVel* unsafe_arena_release_cmd_vel();

  // .ZSS.New.CmdPose cmd_pose = 9;
  bool has_cmd_pose() const;
  private:
  bool _internal_has_cmd_pose() const;
  public:
  void clear_cmd_pose();
  const ::ZSS::New::CmdPose& cmd_pose() const;
  ::ZSS::New::CmdPose* release_cmd_pose();
  ::ZSS::New::CmdPose* mutable_cmd_pose();
  void set_allocated_cmd_pose(::ZSS::New::CmdPose* cmd_pose);
  private:
  const ::ZSS::New::CmdPose& _internal_cmd_pose() const;
  ::ZSS::New::CmdPose* _internal_mutable_cmd_pose();
  public:
  void unsafe_arena_set_allocated_cmd_pose(
      ::ZSS::New::CmdPose* cmd_pose);
  ::ZSS::New::CmdPose* unsafe_arena_release_cmd_pose();

  // .ZSS.New.CmdChase cmd_chase = 10;
  bool has_cmd_chase() const;
  private:
  bool _internal_has_cmd_chase() const;
  public:
  void clear_cmd_chase();
  const ::ZSS::New::CmdChase& cmd_chase() const;
  ::ZSS::New::CmdChase* release_cmd_chase();
  ::ZSS::New::CmdChase* mutable_cmd_chase();
  void set_allocated_cmd_chase(::ZSS::New::CmdChase* cmd_chase);
  private:
  const ::ZSS::New::CmdChase& _internal_cmd_chase() const;
  ::ZSS::New::CmdChase* _internal_mutable_cmd_chase();
  public:
  void unsafe_arena_set_allocated_cmd_chase(
      ::ZSS::New::CmdChase* cmd_chase);
  ::ZSS::New::CmdChase* unsafe_arena_release_cmd_chase();

  // .ZSS.New.CmdWheel cmd_wheel = 11;
  bool has_cmd_wheel() const;
  private:
  bool _internal_has_cmd_wheel() const;
  public:
  void clear_cmd_wheel();
  const ::ZSS::New::CmdWheel& cmd_wheel() const;
  ::ZSS::New::CmdWheel* release_cmd_wheel();
  ::ZSS::New::CmdWheel* mutable_cmd_wheel();
  void set_allocated_cmd_wheel(::ZSS::New::CmdWheel* cmd_wheel);
  private:
  const ::ZSS::New::CmdWheel& _internal_cmd_wheel() const;
  ::ZSS::New::CmdWheel* _internal_mutable_cmd_wheel();
  public:
  void unsafe_arena_set_allocated_cmd_wheel(
      ::ZSS::New::CmdWheel* cmd_wheel);
  ::ZSS::New::CmdWheel* unsafe_arena_release_cmd_wheel();

  // int32 robot_id = 1;
  void clear_robot_id();
  ::PROTOBUF_NAMESPACE_ID::int32 robot_id() const;
  void set_robot_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_robot_id() const;
  void _internal_set_robot_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .ZSS.New.Robot_Command.KickMode kick_mode = 2;
  void clear_kick_mode();
  ::ZSS::New::Robot_Command_KickMode kick_mode() const;
  void set_kick_mode(::ZSS::New::Robot_Command_KickMode value);
  private:
  ::ZSS::New::Robot_Command_KickMode _internal_kick_mode() const;
  void _internal_set_kick_mode(::ZSS::New::Robot_Command_KickMode value);
  public:

  // float desire_power = 3;
  void clear_desire_power();
  float desire_power() const;
  void set_desire_power(float value);
  private:
  float _internal_desire_power() const;
  void _internal_set_desire_power(float value);
  public:

  // float kick_discharge_time = 4;
  void clear_kick_discharge_time();
  float kick_discharge_time() const;
  void set_kick_discharge_time(float value);
  private:
  float _internal_kick_discharge_time() const;
  void _internal_set_kick_discharge_time(float value);
  public:

  // float dribble_spin = 5;
  void clear_dribble_spin();
  float dribble_spin() const;
  void set_dribble_spin(float value);
  private:
  float _internal_dribble_spin() const;
  void _internal_set_dribble_spin(float value);
  public:

  // bool need_report = 6;
  void clear_need_report();
  bool need_report() const;
  void set_need_report(bool value);
  private:
  bool _internal_need_report() const;
  void _internal_set_need_report(bool value);
  public:

  // .ZSS.New.Robot_Command.CmdType cmd_type = 7;
  void clear_cmd_type();
  ::ZSS::New::Robot_Command_CmdType cmd_type() const;
  void set_cmd_type(::ZSS::New::Robot_Command_CmdType value);
  private:
  ::ZSS::New::Robot_Command_CmdType _internal_cmd_type() const;
  void _internal_set_cmd_type(::ZSS::New::Robot_Command_CmdType value);
  public:

  // .ZSS.New.Robot_Command.CommType comm_type = 12;
  void clear_comm_type();
  ::ZSS::New::Robot_Command_CommType comm_type() const;
  void set_comm_type(::ZSS::New::Robot_Command_CommType value);
  private:
  ::ZSS::New::Robot_Command_CommType _internal_comm_type() const;
  void _internal_set_comm_type(::ZSS::New::Robot_Command_CommType value);
  public:

  // @@protoc_insertion_point(class_scope:ZSS.New.Robot_Command)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ZSS::New::CmdVel* cmd_vel_;
  ::ZSS::New::CmdPose* cmd_pose_;
  ::ZSS::New::CmdChase* cmd_chase_;
  ::ZSS::New::CmdWheel* cmd_wheel_;
  ::PROTOBUF_NAMESPACE_ID::int32 robot_id_;
  int kick_mode_;
  float desire_power_;
  float kick_discharge_time_;
  float dribble_spin_;
  bool need_report_;
  int cmd_type_;
  int comm_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zss_5fcmd_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Robots_Status

// repeated .ZSS.New.Robot_Status robots_status = 1;
inline int Robots_Status::_internal_robots_status_size() const {
  return robots_status_.size();
}
inline int Robots_Status::robots_status_size() const {
  return _internal_robots_status_size();
}
inline void Robots_Status::clear_robots_status() {
  robots_status_.Clear();
}
inline ::ZSS::New::Robot_Status* Robots_Status::mutable_robots_status(int index) {
  // @@protoc_insertion_point(field_mutable:ZSS.New.Robots_Status.robots_status)
  return robots_status_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ZSS::New::Robot_Status >*
Robots_Status::mutable_robots_status() {
  // @@protoc_insertion_point(field_mutable_list:ZSS.New.Robots_Status.robots_status)
  return &robots_status_;
}
inline const ::ZSS::New::Robot_Status& Robots_Status::_internal_robots_status(int index) const {
  return robots_status_.Get(index);
}
inline const ::ZSS::New::Robot_Status& Robots_Status::robots_status(int index) const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robots_Status.robots_status)
  return _internal_robots_status(index);
}
inline ::ZSS::New::Robot_Status* Robots_Status::_internal_add_robots_status() {
  return robots_status_.Add();
}
inline ::ZSS::New::Robot_Status* Robots_Status::add_robots_status() {
  // @@protoc_insertion_point(field_add:ZSS.New.Robots_Status.robots_status)
  return _internal_add_robots_status();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ZSS::New::Robot_Status >&
Robots_Status::robots_status() const {
  // @@protoc_insertion_point(field_list:ZSS.New.Robots_Status.robots_status)
  return robots_status_;
}

// -------------------------------------------------------------------

// Multicast_Status

// string ip = 1;
inline void Multicast_Status::clear_ip() {
  ip_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Multicast_Status::ip() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Multicast_Status.ip)
  return _internal_ip();
}
inline void Multicast_Status::set_ip(const std::string& value) {
  _internal_set_ip(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Multicast_Status.ip)
}
inline std::string* Multicast_Status::mutable_ip() {
  // @@protoc_insertion_point(field_mutable:ZSS.New.Multicast_Status.ip)
  return _internal_mutable_ip();
}
inline const std::string& Multicast_Status::_internal_ip() const {
  return ip_.Get();
}
inline void Multicast_Status::_internal_set_ip(const std::string& value) {
  
  ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Multicast_Status::set_ip(std::string&& value) {
  
  ip_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ZSS.New.Multicast_Status.ip)
}
inline void Multicast_Status::set_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ZSS.New.Multicast_Status.ip)
}
inline void Multicast_Status::set_ip(const char* value,
    size_t size) {
  
  ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ZSS.New.Multicast_Status.ip)
}
inline std::string* Multicast_Status::_internal_mutable_ip() {
  
  return ip_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Multicast_Status::release_ip() {
  // @@protoc_insertion_point(field_release:ZSS.New.Multicast_Status.ip)
  return ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Multicast_Status::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ZSS.New.Multicast_Status.ip)
}
inline std::string* Multicast_Status::unsafe_arena_release_ip() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ZSS.New.Multicast_Status.ip)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return ip_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Multicast_Status::unsafe_arena_set_allocated_ip(
    std::string* ip) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ip, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ZSS.New.Multicast_Status.ip)
}

// string uuid = 2;
inline void Multicast_Status::clear_uuid() {
  uuid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Multicast_Status::uuid() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Multicast_Status.uuid)
  return _internal_uuid();
}
inline void Multicast_Status::set_uuid(const std::string& value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Multicast_Status.uuid)
}
inline std::string* Multicast_Status::mutable_uuid() {
  // @@protoc_insertion_point(field_mutable:ZSS.New.Multicast_Status.uuid)
  return _internal_mutable_uuid();
}
inline const std::string& Multicast_Status::_internal_uuid() const {
  return uuid_.Get();
}
inline void Multicast_Status::_internal_set_uuid(const std::string& value) {
  
  uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Multicast_Status::set_uuid(std::string&& value) {
  
  uuid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ZSS.New.Multicast_Status.uuid)
}
inline void Multicast_Status::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ZSS.New.Multicast_Status.uuid)
}
inline void Multicast_Status::set_uuid(const char* value,
    size_t size) {
  
  uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ZSS.New.Multicast_Status.uuid)
}
inline std::string* Multicast_Status::_internal_mutable_uuid() {
  
  return uuid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Multicast_Status::release_uuid() {
  // @@protoc_insertion_point(field_release:ZSS.New.Multicast_Status.uuid)
  return uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Multicast_Status::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uuid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ZSS.New.Multicast_Status.uuid)
}
inline std::string* Multicast_Status::unsafe_arena_release_uuid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ZSS.New.Multicast_Status.uuid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return uuid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Multicast_Status::unsafe_arena_set_allocated_uuid(
    std::string* uuid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (uuid != nullptr) {
    
  } else {
    
  }
  uuid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      uuid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ZSS.New.Multicast_Status.uuid)
}

// .ZSS.New.Team team = 3;
inline void Multicast_Status::clear_team() {
  team_ = 0;
}
inline ::ZSS::New::Team Multicast_Status::_internal_team() const {
  return static_cast< ::ZSS::New::Team >(team_);
}
inline ::ZSS::New::Team Multicast_Status::team() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Multicast_Status.team)
  return _internal_team();
}
inline void Multicast_Status::_internal_set_team(::ZSS::New::Team value) {
  
  team_ = value;
}
inline void Multicast_Status::set_team(::ZSS::New::Team value) {
  _internal_set_team(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Multicast_Status.team)
}

// int32 robot_id = 4;
inline void Multicast_Status::clear_robot_id() {
  robot_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Multicast_Status::_internal_robot_id() const {
  return robot_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Multicast_Status::robot_id() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Multicast_Status.robot_id)
  return _internal_robot_id();
}
inline void Multicast_Status::_internal_set_robot_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  robot_id_ = value;
}
inline void Multicast_Status::set_robot_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_robot_id(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Multicast_Status.robot_id)
}

// float battery = 5;
inline void Multicast_Status::clear_battery() {
  battery_ = 0;
}
inline float Multicast_Status::_internal_battery() const {
  return battery_;
}
inline float Multicast_Status::battery() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Multicast_Status.battery)
  return _internal_battery();
}
inline void Multicast_Status::_internal_set_battery(float value) {
  
  battery_ = value;
}
inline void Multicast_Status::set_battery(float value) {
  _internal_set_battery(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Multicast_Status.battery)
}

// float capacitance = 6;
inline void Multicast_Status::clear_capacitance() {
  capacitance_ = 0;
}
inline float Multicast_Status::_internal_capacitance() const {
  return capacitance_;
}
inline float Multicast_Status::capacitance() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Multicast_Status.capacitance)
  return _internal_capacitance();
}
inline void Multicast_Status::_internal_set_capacitance(float value) {
  
  capacitance_ = value;
}
inline void Multicast_Status::set_capacitance(float value) {
  _internal_set_capacitance(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Multicast_Status.capacitance)
}

// -------------------------------------------------------------------

// Robot_Status

// int32 robot_id = 1;
inline void Robot_Status::clear_robot_id() {
  robot_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Robot_Status::_internal_robot_id() const {
  return robot_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Robot_Status::robot_id() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Status.robot_id)
  return _internal_robot_id();
}
inline void Robot_Status::_internal_set_robot_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  robot_id_ = value;
}
inline void Robot_Status::set_robot_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_robot_id(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Robot_Status.robot_id)
}

// float infrared = 2;
inline void Robot_Status::clear_infrared() {
  infrared_ = 0;
}
inline float Robot_Status::_internal_infrared() const {
  return infrared_;
}
inline float Robot_Status::infrared() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Status.infrared)
  return _internal_infrared();
}
inline void Robot_Status::_internal_set_infrared(float value) {
  
  infrared_ = value;
}
inline void Robot_Status::set_infrared(float value) {
  _internal_set_infrared(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Robot_Status.infrared)
}

// float flat_kick = 3;
inline void Robot_Status::clear_flat_kick() {
  flat_kick_ = 0;
}
inline float Robot_Status::_internal_flat_kick() const {
  return flat_kick_;
}
inline float Robot_Status::flat_kick() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Status.flat_kick)
  return _internal_flat_kick();
}
inline void Robot_Status::_internal_set_flat_kick(float value) {
  
  flat_kick_ = value;
}
inline void Robot_Status::set_flat_kick(float value) {
  _internal_set_flat_kick(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Robot_Status.flat_kick)
}

// float chip_kick = 4;
inline void Robot_Status::clear_chip_kick() {
  chip_kick_ = 0;
}
inline float Robot_Status::_internal_chip_kick() const {
  return chip_kick_;
}
inline float Robot_Status::chip_kick() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Status.chip_kick)
  return _internal_chip_kick();
}
inline void Robot_Status::_internal_set_chip_kick(float value) {
  
  chip_kick_ = value;
}
inline void Robot_Status::set_chip_kick(float value) {
  _internal_set_chip_kick(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Robot_Status.chip_kick)
}

// float imu_theta = 5;
inline void Robot_Status::clear_imu_theta() {
  imu_theta_ = 0;
}
inline float Robot_Status::_internal_imu_theta() const {
  return imu_theta_;
}
inline float Robot_Status::imu_theta() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Status.imu_theta)
  return _internal_imu_theta();
}
inline void Robot_Status::_internal_set_imu_theta(float value) {
  
  imu_theta_ = value;
}
inline void Robot_Status::set_imu_theta(float value) {
  _internal_set_imu_theta(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Robot_Status.imu_theta)
}

// float battery = 6;
inline void Robot_Status::clear_battery() {
  battery_ = 0;
}
inline float Robot_Status::_internal_battery() const {
  return battery_;
}
inline float Robot_Status::battery() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Status.battery)
  return _internal_battery();
}
inline void Robot_Status::_internal_set_battery(float value) {
  
  battery_ = value;
}
inline void Robot_Status::set_battery(float value) {
  _internal_set_battery(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Robot_Status.battery)
}

// float capacitance = 7;
inline void Robot_Status::clear_capacitance() {
  capacitance_ = 0;
}
inline float Robot_Status::_internal_capacitance() const {
  return capacitance_;
}
inline float Robot_Status::capacitance() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Status.capacitance)
  return _internal_capacitance();
}
inline void Robot_Status::_internal_set_capacitance(float value) {
  
  capacitance_ = value;
}
inline void Robot_Status::set_capacitance(float value) {
  _internal_set_capacitance(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Robot_Status.capacitance)
}

// .ZSS.New.Odom odom = 8;
inline bool Robot_Status::_internal_has_odom() const {
  return this != internal_default_instance() && odom_ != nullptr;
}
inline bool Robot_Status::has_odom() const {
  return _internal_has_odom();
}
inline const ::ZSS::New::Odom& Robot_Status::_internal_odom() const {
  const ::ZSS::New::Odom* p = odom_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ZSS::New::Odom*>(
      &::ZSS::New::_Odom_default_instance_);
}
inline const ::ZSS::New::Odom& Robot_Status::odom() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Status.odom)
  return _internal_odom();
}
inline void Robot_Status::unsafe_arena_set_allocated_odom(
    ::ZSS::New::Odom* odom) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(odom_);
  }
  odom_ = odom;
  if (odom) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ZSS.New.Robot_Status.odom)
}
inline ::ZSS::New::Odom* Robot_Status::release_odom() {
  auto temp = unsafe_arena_release_odom();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ZSS::New::Odom* Robot_Status::unsafe_arena_release_odom() {
  // @@protoc_insertion_point(field_release:ZSS.New.Robot_Status.odom)
  
  ::ZSS::New::Odom* temp = odom_;
  odom_ = nullptr;
  return temp;
}
inline ::ZSS::New::Odom* Robot_Status::_internal_mutable_odom() {
  
  if (odom_ == nullptr) {
    auto* p = CreateMaybeMessage<::ZSS::New::Odom>(GetArena());
    odom_ = p;
  }
  return odom_;
}
inline ::ZSS::New::Odom* Robot_Status::mutable_odom() {
  // @@protoc_insertion_point(field_mutable:ZSS.New.Robot_Status.odom)
  return _internal_mutable_odom();
}
inline void Robot_Status::set_allocated_odom(::ZSS::New::Odom* odom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(odom_);
  }
  if (odom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(odom)->GetArena();
    if (message_arena != submessage_arena) {
      odom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, odom, submessage_arena);
    }
    
  } else {
    
  }
  odom_ = odom;
  // @@protoc_insertion_point(field_set_allocated:ZSS.New.Robot_Status.odom)
}

// repeated float wheel_encoder = 9;
inline int Robot_Status::_internal_wheel_encoder_size() const {
  return wheel_encoder_.size();
}
inline int Robot_Status::wheel_encoder_size() const {
  return _internal_wheel_encoder_size();
}
inline void Robot_Status::clear_wheel_encoder() {
  wheel_encoder_.Clear();
}
inline float Robot_Status::_internal_wheel_encoder(int index) const {
  return wheel_encoder_.Get(index);
}
inline float Robot_Status::wheel_encoder(int index) const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Status.wheel_encoder)
  return _internal_wheel_encoder(index);
}
inline void Robot_Status::set_wheel_encoder(int index, float value) {
  wheel_encoder_.Set(index, value);
  // @@protoc_insertion_point(field_set:ZSS.New.Robot_Status.wheel_encoder)
}
inline void Robot_Status::_internal_add_wheel_encoder(float value) {
  wheel_encoder_.Add(value);
}
inline void Robot_Status::add_wheel_encoder(float value) {
  _internal_add_wheel_encoder(value);
  // @@protoc_insertion_point(field_add:ZSS.New.Robot_Status.wheel_encoder)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Robot_Status::_internal_wheel_encoder() const {
  return wheel_encoder_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Robot_Status::wheel_encoder() const {
  // @@protoc_insertion_point(field_list:ZSS.New.Robot_Status.wheel_encoder)
  return _internal_wheel_encoder();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Robot_Status::_internal_mutable_wheel_encoder() {
  return &wheel_encoder_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Robot_Status::mutable_wheel_encoder() {
  // @@protoc_insertion_point(field_mutable_list:ZSS.New.Robot_Status.wheel_encoder)
  return _internal_mutable_wheel_encoder();
}

// .ZSS.New.Team team = 10;
inline void Robot_Status::clear_team() {
  team_ = 0;
}
inline ::ZSS::New::Team Robot_Status::_internal_team() const {
  return static_cast< ::ZSS::New::Team >(team_);
}
inline ::ZSS::New::Team Robot_Status::team() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Status.team)
  return _internal_team();
}
inline void Robot_Status::_internal_set_team(::ZSS::New::Team value) {
  
  team_ = value;
}
inline void Robot_Status::set_team(::ZSS::New::Team value) {
  _internal_set_team(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Robot_Status.team)
}

// -------------------------------------------------------------------

// Robots_Command

// repeated .ZSS.New.Robot_Command command = 1;
inline int Robots_Command::_internal_command_size() const {
  return command_.size();
}
inline int Robots_Command::command_size() const {
  return _internal_command_size();
}
inline void Robots_Command::clear_command() {
  command_.Clear();
}
inline ::ZSS::New::Robot_Command* Robots_Command::mutable_command(int index) {
  // @@protoc_insertion_point(field_mutable:ZSS.New.Robots_Command.command)
  return command_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ZSS::New::Robot_Command >*
Robots_Command::mutable_command() {
  // @@protoc_insertion_point(field_mutable_list:ZSS.New.Robots_Command.command)
  return &command_;
}
inline const ::ZSS::New::Robot_Command& Robots_Command::_internal_command(int index) const {
  return command_.Get(index);
}
inline const ::ZSS::New::Robot_Command& Robots_Command::command(int index) const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robots_Command.command)
  return _internal_command(index);
}
inline ::ZSS::New::Robot_Command* Robots_Command::_internal_add_command() {
  return command_.Add();
}
inline ::ZSS::New::Robot_Command* Robots_Command::add_command() {
  // @@protoc_insertion_point(field_add:ZSS.New.Robots_Command.command)
  return _internal_add_command();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ZSS::New::Robot_Command >&
Robots_Command::command() const {
  // @@protoc_insertion_point(field_list:ZSS.New.Robots_Command.command)
  return command_;
}

// int32 delay = 2;
inline bool Robots_Command::_internal_has_delay() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Robots_Command::has_delay() const {
  return _internal_has_delay();
}
inline void Robots_Command::clear_delay() {
  delay_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Robots_Command::_internal_delay() const {
  return delay_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Robots_Command::delay() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robots_Command.delay)
  return _internal_delay();
}
inline void Robots_Command::_internal_set_delay(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  delay_ = value;
}
inline void Robots_Command::set_delay(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_delay(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Robots_Command.delay)
}

// -------------------------------------------------------------------

// Robot_Command

// int32 robot_id = 1;
inline void Robot_Command::clear_robot_id() {
  robot_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Robot_Command::_internal_robot_id() const {
  return robot_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Robot_Command::robot_id() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Command.robot_id)
  return _internal_robot_id();
}
inline void Robot_Command::_internal_set_robot_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  robot_id_ = value;
}
inline void Robot_Command::set_robot_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_robot_id(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Robot_Command.robot_id)
}

// .ZSS.New.Robot_Command.KickMode kick_mode = 2;
inline void Robot_Command::clear_kick_mode() {
  kick_mode_ = 0;
}
inline ::ZSS::New::Robot_Command_KickMode Robot_Command::_internal_kick_mode() const {
  return static_cast< ::ZSS::New::Robot_Command_KickMode >(kick_mode_);
}
inline ::ZSS::New::Robot_Command_KickMode Robot_Command::kick_mode() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Command.kick_mode)
  return _internal_kick_mode();
}
inline void Robot_Command::_internal_set_kick_mode(::ZSS::New::Robot_Command_KickMode value) {
  
  kick_mode_ = value;
}
inline void Robot_Command::set_kick_mode(::ZSS::New::Robot_Command_KickMode value) {
  _internal_set_kick_mode(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Robot_Command.kick_mode)
}

// float desire_power = 3;
inline void Robot_Command::clear_desire_power() {
  desire_power_ = 0;
}
inline float Robot_Command::_internal_desire_power() const {
  return desire_power_;
}
inline float Robot_Command::desire_power() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Command.desire_power)
  return _internal_desire_power();
}
inline void Robot_Command::_internal_set_desire_power(float value) {
  
  desire_power_ = value;
}
inline void Robot_Command::set_desire_power(float value) {
  _internal_set_desire_power(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Robot_Command.desire_power)
}

// float kick_discharge_time = 4;
inline void Robot_Command::clear_kick_discharge_time() {
  kick_discharge_time_ = 0;
}
inline float Robot_Command::_internal_kick_discharge_time() const {
  return kick_discharge_time_;
}
inline float Robot_Command::kick_discharge_time() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Command.kick_discharge_time)
  return _internal_kick_discharge_time();
}
inline void Robot_Command::_internal_set_kick_discharge_time(float value) {
  
  kick_discharge_time_ = value;
}
inline void Robot_Command::set_kick_discharge_time(float value) {
  _internal_set_kick_discharge_time(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Robot_Command.kick_discharge_time)
}

// float dribble_spin = 5;
inline void Robot_Command::clear_dribble_spin() {
  dribble_spin_ = 0;
}
inline float Robot_Command::_internal_dribble_spin() const {
  return dribble_spin_;
}
inline float Robot_Command::dribble_spin() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Command.dribble_spin)
  return _internal_dribble_spin();
}
inline void Robot_Command::_internal_set_dribble_spin(float value) {
  
  dribble_spin_ = value;
}
inline void Robot_Command::set_dribble_spin(float value) {
  _internal_set_dribble_spin(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Robot_Command.dribble_spin)
}

// bool need_report = 6;
inline void Robot_Command::clear_need_report() {
  need_report_ = false;
}
inline bool Robot_Command::_internal_need_report() const {
  return need_report_;
}
inline bool Robot_Command::need_report() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Command.need_report)
  return _internal_need_report();
}
inline void Robot_Command::_internal_set_need_report(bool value) {
  
  need_report_ = value;
}
inline void Robot_Command::set_need_report(bool value) {
  _internal_set_need_report(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Robot_Command.need_report)
}

// .ZSS.New.Robot_Command.CmdType cmd_type = 7;
inline void Robot_Command::clear_cmd_type() {
  cmd_type_ = 0;
}
inline ::ZSS::New::Robot_Command_CmdType Robot_Command::_internal_cmd_type() const {
  return static_cast< ::ZSS::New::Robot_Command_CmdType >(cmd_type_);
}
inline ::ZSS::New::Robot_Command_CmdType Robot_Command::cmd_type() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Command.cmd_type)
  return _internal_cmd_type();
}
inline void Robot_Command::_internal_set_cmd_type(::ZSS::New::Robot_Command_CmdType value) {
  
  cmd_type_ = value;
}
inline void Robot_Command::set_cmd_type(::ZSS::New::Robot_Command_CmdType value) {
  _internal_set_cmd_type(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Robot_Command.cmd_type)
}

// .ZSS.New.CmdVel cmd_vel = 8;
inline bool Robot_Command::_internal_has_cmd_vel() const {
  return this != internal_default_instance() && cmd_vel_ != nullptr;
}
inline bool Robot_Command::has_cmd_vel() const {
  return _internal_has_cmd_vel();
}
inline const ::ZSS::New::CmdVel& Robot_Command::_internal_cmd_vel() const {
  const ::ZSS::New::CmdVel* p = cmd_vel_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ZSS::New::CmdVel*>(
      &::ZSS::New::_CmdVel_default_instance_);
}
inline const ::ZSS::New::CmdVel& Robot_Command::cmd_vel() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Command.cmd_vel)
  return _internal_cmd_vel();
}
inline void Robot_Command::unsafe_arena_set_allocated_cmd_vel(
    ::ZSS::New::CmdVel* cmd_vel) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cmd_vel_);
  }
  cmd_vel_ = cmd_vel;
  if (cmd_vel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ZSS.New.Robot_Command.cmd_vel)
}
inline ::ZSS::New::CmdVel* Robot_Command::release_cmd_vel() {
  auto temp = unsafe_arena_release_cmd_vel();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ZSS::New::CmdVel* Robot_Command::unsafe_arena_release_cmd_vel() {
  // @@protoc_insertion_point(field_release:ZSS.New.Robot_Command.cmd_vel)
  
  ::ZSS::New::CmdVel* temp = cmd_vel_;
  cmd_vel_ = nullptr;
  return temp;
}
inline ::ZSS::New::CmdVel* Robot_Command::_internal_mutable_cmd_vel() {
  
  if (cmd_vel_ == nullptr) {
    auto* p = CreateMaybeMessage<::ZSS::New::CmdVel>(GetArena());
    cmd_vel_ = p;
  }
  return cmd_vel_;
}
inline ::ZSS::New::CmdVel* Robot_Command::mutable_cmd_vel() {
  // @@protoc_insertion_point(field_mutable:ZSS.New.Robot_Command.cmd_vel)
  return _internal_mutable_cmd_vel();
}
inline void Robot_Command::set_allocated_cmd_vel(::ZSS::New::CmdVel* cmd_vel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cmd_vel_);
  }
  if (cmd_vel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cmd_vel)->GetArena();
    if (message_arena != submessage_arena) {
      cmd_vel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cmd_vel, submessage_arena);
    }
    
  } else {
    
  }
  cmd_vel_ = cmd_vel;
  // @@protoc_insertion_point(field_set_allocated:ZSS.New.Robot_Command.cmd_vel)
}

// .ZSS.New.CmdPose cmd_pose = 9;
inline bool Robot_Command::_internal_has_cmd_pose() const {
  return this != internal_default_instance() && cmd_pose_ != nullptr;
}
inline bool Robot_Command::has_cmd_pose() const {
  return _internal_has_cmd_pose();
}
inline const ::ZSS::New::CmdPose& Robot_Command::_internal_cmd_pose() const {
  const ::ZSS::New::CmdPose* p = cmd_pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ZSS::New::CmdPose*>(
      &::ZSS::New::_CmdPose_default_instance_);
}
inline const ::ZSS::New::CmdPose& Robot_Command::cmd_pose() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Command.cmd_pose)
  return _internal_cmd_pose();
}
inline void Robot_Command::unsafe_arena_set_allocated_cmd_pose(
    ::ZSS::New::CmdPose* cmd_pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cmd_pose_);
  }
  cmd_pose_ = cmd_pose;
  if (cmd_pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ZSS.New.Robot_Command.cmd_pose)
}
inline ::ZSS::New::CmdPose* Robot_Command::release_cmd_pose() {
  auto temp = unsafe_arena_release_cmd_pose();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ZSS::New::CmdPose* Robot_Command::unsafe_arena_release_cmd_pose() {
  // @@protoc_insertion_point(field_release:ZSS.New.Robot_Command.cmd_pose)
  
  ::ZSS::New::CmdPose* temp = cmd_pose_;
  cmd_pose_ = nullptr;
  return temp;
}
inline ::ZSS::New::CmdPose* Robot_Command::_internal_mutable_cmd_pose() {
  
  if (cmd_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::ZSS::New::CmdPose>(GetArena());
    cmd_pose_ = p;
  }
  return cmd_pose_;
}
inline ::ZSS::New::CmdPose* Robot_Command::mutable_cmd_pose() {
  // @@protoc_insertion_point(field_mutable:ZSS.New.Robot_Command.cmd_pose)
  return _internal_mutable_cmd_pose();
}
inline void Robot_Command::set_allocated_cmd_pose(::ZSS::New::CmdPose* cmd_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cmd_pose_);
  }
  if (cmd_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cmd_pose)->GetArena();
    if (message_arena != submessage_arena) {
      cmd_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cmd_pose, submessage_arena);
    }
    
  } else {
    
  }
  cmd_pose_ = cmd_pose;
  // @@protoc_insertion_point(field_set_allocated:ZSS.New.Robot_Command.cmd_pose)
}

// .ZSS.New.CmdChase cmd_chase = 10;
inline bool Robot_Command::_internal_has_cmd_chase() const {
  return this != internal_default_instance() && cmd_chase_ != nullptr;
}
inline bool Robot_Command::has_cmd_chase() const {
  return _internal_has_cmd_chase();
}
inline const ::ZSS::New::CmdChase& Robot_Command::_internal_cmd_chase() const {
  const ::ZSS::New::CmdChase* p = cmd_chase_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ZSS::New::CmdChase*>(
      &::ZSS::New::_CmdChase_default_instance_);
}
inline const ::ZSS::New::CmdChase& Robot_Command::cmd_chase() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Command.cmd_chase)
  return _internal_cmd_chase();
}
inline void Robot_Command::unsafe_arena_set_allocated_cmd_chase(
    ::ZSS::New::CmdChase* cmd_chase) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cmd_chase_);
  }
  cmd_chase_ = cmd_chase;
  if (cmd_chase) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ZSS.New.Robot_Command.cmd_chase)
}
inline ::ZSS::New::CmdChase* Robot_Command::release_cmd_chase() {
  auto temp = unsafe_arena_release_cmd_chase();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ZSS::New::CmdChase* Robot_Command::unsafe_arena_release_cmd_chase() {
  // @@protoc_insertion_point(field_release:ZSS.New.Robot_Command.cmd_chase)
  
  ::ZSS::New::CmdChase* temp = cmd_chase_;
  cmd_chase_ = nullptr;
  return temp;
}
inline ::ZSS::New::CmdChase* Robot_Command::_internal_mutable_cmd_chase() {
  
  if (cmd_chase_ == nullptr) {
    auto* p = CreateMaybeMessage<::ZSS::New::CmdChase>(GetArena());
    cmd_chase_ = p;
  }
  return cmd_chase_;
}
inline ::ZSS::New::CmdChase* Robot_Command::mutable_cmd_chase() {
  // @@protoc_insertion_point(field_mutable:ZSS.New.Robot_Command.cmd_chase)
  return _internal_mutable_cmd_chase();
}
inline void Robot_Command::set_allocated_cmd_chase(::ZSS::New::CmdChase* cmd_chase) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cmd_chase_);
  }
  if (cmd_chase) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cmd_chase)->GetArena();
    if (message_arena != submessage_arena) {
      cmd_chase = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cmd_chase, submessage_arena);
    }
    
  } else {
    
  }
  cmd_chase_ = cmd_chase;
  // @@protoc_insertion_point(field_set_allocated:ZSS.New.Robot_Command.cmd_chase)
}

// .ZSS.New.CmdWheel cmd_wheel = 11;
inline bool Robot_Command::_internal_has_cmd_wheel() const {
  return this != internal_default_instance() && cmd_wheel_ != nullptr;
}
inline bool Robot_Command::has_cmd_wheel() const {
  return _internal_has_cmd_wheel();
}
inline const ::ZSS::New::CmdWheel& Robot_Command::_internal_cmd_wheel() const {
  const ::ZSS::New::CmdWheel* p = cmd_wheel_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ZSS::New::CmdWheel*>(
      &::ZSS::New::_CmdWheel_default_instance_);
}
inline const ::ZSS::New::CmdWheel& Robot_Command::cmd_wheel() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Command.cmd_wheel)
  return _internal_cmd_wheel();
}
inline void Robot_Command::unsafe_arena_set_allocated_cmd_wheel(
    ::ZSS::New::CmdWheel* cmd_wheel) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cmd_wheel_);
  }
  cmd_wheel_ = cmd_wheel;
  if (cmd_wheel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ZSS.New.Robot_Command.cmd_wheel)
}
inline ::ZSS::New::CmdWheel* Robot_Command::release_cmd_wheel() {
  auto temp = unsafe_arena_release_cmd_wheel();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ZSS::New::CmdWheel* Robot_Command::unsafe_arena_release_cmd_wheel() {
  // @@protoc_insertion_point(field_release:ZSS.New.Robot_Command.cmd_wheel)
  
  ::ZSS::New::CmdWheel* temp = cmd_wheel_;
  cmd_wheel_ = nullptr;
  return temp;
}
inline ::ZSS::New::CmdWheel* Robot_Command::_internal_mutable_cmd_wheel() {
  
  if (cmd_wheel_ == nullptr) {
    auto* p = CreateMaybeMessage<::ZSS::New::CmdWheel>(GetArena());
    cmd_wheel_ = p;
  }
  return cmd_wheel_;
}
inline ::ZSS::New::CmdWheel* Robot_Command::mutable_cmd_wheel() {
  // @@protoc_insertion_point(field_mutable:ZSS.New.Robot_Command.cmd_wheel)
  return _internal_mutable_cmd_wheel();
}
inline void Robot_Command::set_allocated_cmd_wheel(::ZSS::New::CmdWheel* cmd_wheel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cmd_wheel_);
  }
  if (cmd_wheel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cmd_wheel)->GetArena();
    if (message_arena != submessage_arena) {
      cmd_wheel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cmd_wheel, submessage_arena);
    }
    
  } else {
    
  }
  cmd_wheel_ = cmd_wheel;
  // @@protoc_insertion_point(field_set_allocated:ZSS.New.Robot_Command.cmd_wheel)
}

// .ZSS.New.Robot_Command.CommType comm_type = 12;
inline void Robot_Command::clear_comm_type() {
  comm_type_ = 0;
}
inline ::ZSS::New::Robot_Command_CommType Robot_Command::_internal_comm_type() const {
  return static_cast< ::ZSS::New::Robot_Command_CommType >(comm_type_);
}
inline ::ZSS::New::Robot_Command_CommType Robot_Command::comm_type() const {
  // @@protoc_insertion_point(field_get:ZSS.New.Robot_Command.comm_type)
  return _internal_comm_type();
}
inline void Robot_Command::_internal_set_comm_type(::ZSS::New::Robot_Command_CommType value) {
  
  comm_type_ = value;
}
inline void Robot_Command::set_comm_type(::ZSS::New::Robot_Command_CommType value) {
  _internal_set_comm_type(value);
  // @@protoc_insertion_point(field_set:ZSS.New.Robot_Command.comm_type)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace New
}  // namespace ZSS

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ZSS::New::Robot_Command_KickMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ZSS::New::Robot_Command_KickMode>() {
  return ::ZSS::New::Robot_Command_KickMode_descriptor();
}
template <> struct is_proto_enum< ::ZSS::New::Robot_Command_CmdType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ZSS::New::Robot_Command_CmdType>() {
  return ::ZSS::New::Robot_Command_CmdType_descriptor();
}
template <> struct is_proto_enum< ::ZSS::New::Robot_Command_CommType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ZSS::New::Robot_Command_CommType>() {
  return ::ZSS::New::Robot_Command_CommType_descriptor();
}
template <> struct is_proto_enum< ::ZSS::New::Team> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ZSS::New::Team>() {
  return ::ZSS::New::Team_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_zss_5fcmd_2eproto
